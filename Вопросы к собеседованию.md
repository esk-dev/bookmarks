

[GitHub - ninja-js/js-interview: Вопросы и ответы для собеседования Front-end/JS разработчика и не только](https://github.com/ninja-js/js-interview#5)

- **JavaScript**
    - **Как устроена память в JavaScript (memory heap, memory stack)?**
    - **В чем отличие var от const, let?**
    - **Что такое call-stack, task-queue (приведите примеры работы)?**
    - **Что такое макро и микро задачи в JS?**
    - **Какие существуют типы данных в JS?**
        
        number, string, bigInt, array, object, undefined, null, boolean
        Object - ссылочный тип данных
        
        [Типы данных](https://learn.javascript.ru/types)
        
    - **Приведите примеры приведения к логическому типу значений, не относящихся к этому типу.**
        
        Оператор "!!" (двойное отрицание) приводит значение справа от него к логическому значению.
        
        Вот список значений, которые можно назвать **ложными** (falsy). Они, при преобразовании к логическому типу, превращаются в значение `false`:
        
        - `""` (пустая строка).
        - `0, -0, NaN` (не-число).
        - `null, undefined`.
        
        Любое значение, которое не входит в этот список, при его преобразовании к логическому типу, превращается в `true` (такие значения называют **истинными** — truthy). Например:
        
        - `"hello"`.
        - `42`.
        - `[ ], [ 1, «2», 3 ]` (массивы).
        - `{ }, { a: 42 }` (объекты).
        - `unction foo() { .. }` (функции).
    - **Что такое распространение события (Event Propagation)?**
        
        [Всплытие и погружение](https://learn.javascript.ru/bubbling-and-capturing)
        
        Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие «распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы:
        
        1. Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события через всех ее предков.
        2. Целевая фаза — это когда событие достигает целевого элемента.
        3. Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает объекта Window.
        
        ![https://habrastorage.org/r/w1560/webt/a3/9x/67/a39x67wkxdmcyzj-it5m2jmfxgg.png](https://habrastorage.org/r/w1560/webt/a3/9x/67/a39x67wkxdmcyzj-it5m2jmfxgg.png)
        
        Подробнее о распространении событий можно почитать
        
        [здесь](https://learn.javascript.ru/bubbling-and-capturing) и [здесь](https://www.w3.org/TR/DOM-Level-3-Events/#event-flow).
        
    - **Для чего используется директива «use strict»?**
        
        «use strict» — это директива ES5, которая заставляет весь наш код или код отдельной функции выполняться в строгом режиме. Строгий режим вводит некоторые ограничения по написанию кода, тем самым позволяя избегать ошибок на ранних этапах.
        
        Вот какие ограничения накладывает строгий режим.
        
        Нельзя присваивать значения или обращаться к необъявленным переменным:
        
        ```
        functionreturnY() {
            'use strict'
            y = 123
        return y
        }
        returnY() // Uncaught ReferenceError: y is not defined
        
        ```
        
        Запрещено присваивать значения глобальный переменным, доступным только для чтения или записи:
        
        ```jsx
        'use strict'
        var NaN = NaN // Uncaught TypeError: Cannot assign to read only property 'NaN' of object '#<Window>'
        var undefined = undefined
        var Infinity = 'and beyond'
        
        ```
        
        Нельзя удалить «неудаляемое» свойство объекта:
        
        ```
        'use strict'
        const obj = {}
        
        Object.defineProperties(obj, 'x', {
            value: 1
        })
        
        delete obj.x // Uncaught TypeError: Property description must be an object: x
        
        ```
        
        Запрещено дублирование параметров:
        
        ```
        'use strict'
        
        functionsomeFunc(a, b, b, c) {} // Uncaught SyntaxError: Duplicate parameter name not allowed in this context
        
        ```
        
        Нельзя создавать функции с помощью функции eval:
        
        ```
        'use strict'
        
        eval('var x = 1')
        
        console.log(x) // Uncaught ReferenceError: x is not defined
        
        ```
        
        Значением «this» по умолчанию является undefined:
        
        ```
        'use strict'
        
        functionshowMeThis() {
        returnthis
        }
        
        showMeThis() // undefined
        ```
        
    - **Что такое DOM?**
        
        DOM или Document Object Model (объектная модель документа) — это прикладной программный интерфейс (API) для работы с HTML и XML документами. Когда браузер первый раз читает («парсит») HTML документ, он формирует большой объект, действительно большой объект, основанный на документе — DOM. DOM представляет собой древовидную структуру (дерево документа). DOM используется для взаимодействия и изменения самой структуры DOM или его отдельных элементов и узлов.
        
        ```jsx
        [document.querySelector](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector)(selector)
        ```
        
        ```jsx
        [document.querySelectorAll](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll)(name)
        ```
        
        ```jsx
        [document.createElement](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement)(name)
        ```
        
        ```jsx
        parentNode.[appendChild](https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild)(node)
        ```
        
        ```jsx
        element.[innerHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)
        ```
        
        ```jsx
        element.[style](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style).left
        ```
        
        ```jsx
        element.[setAttribute](https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute)()
        ```
        
        ```jsx
        element.[getAttribute](https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute)()
        ```
        
        ```jsx
        element.[addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)()
        ```
        
    - **Try/Catch/Finaly**
        
        Конструкция `try..catch` состоит из двух основных блоков: `try`, и затем `catch`:
        
        `try {
        
          // код...
        
        } catch (err) {
        
          // обработка ошибки
        
        }`
        
        Работает она так:
        
        1. Сначала выполняется код внутри блока `try {...}`.
        2. Если в нём нет ошибок, то блок `catch(err)` игнорируется: выполнение доходит до конца `try` и потом далее, полностью пропуская `catch`.
        3. Если же в нём возникает ошибка, то выполнение `try` прерывается, и поток управления переходит в начало `catch(err)`. Переменная `err` (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.
        
        Таким образом, при ошибке в блоке `try {…}`скрипт не «падает», и мы получаем возможность обработать ошибку внутри `catch`.
        
        ### [Объект ошибки](https://learn.javascript.ru/try-catch#obekt-oshibki)
        
        Когда возникает ошибка, JavaScript генерирует объект, содержащий её детали. Затем этот объект передаётся как аргумент в блок `catch`:
        
        `try {
          // ...
        } catch(err) { // <-- объект ошибки, можно использовать другое название вместо err
          // ...
        }`
        
        Для всех встроенных ошибок этот объект имеет два основных свойства:
        
        **`name`**Имя ошибки. Например, для неопределённой переменной это `"ReferenceError"`.**`message`**Текстовое сообщение о деталях ошибки.
        
        В большинстве окружений доступны и другие, нестандартные свойства. Одно из самых широко используемых и поддерживаемых – это:
        
        **`stack`**Текущий стек вызова: строка, содержащая информацию о последовательности вложенных вызовов, которые привели к ошибке. Используется в целях отладки.
        
    - **Промисы**
        
        [`Promise`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise)(промис) - это объект, представляющий результат успешного или неудачного завершения асинхронной операции. 
        
        Промис - это возвращаемый объект, в который вы записываете два колбэка вместо того, чтобы передать их функции.
        
        ---
        
        ```jsx
        let promise = new Promise(function(resolve, reject) {
          // функция-исполнитель (executor)
          // "певец"
        });
        ```
        
        Функция, переданная в конструкцию `new Promise`, называется *исполнитель* (executor). Когда `Promise` создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат.
        
        Её аргументы `resolve` и `reject` – это колбэки, которые предоставляет сам JavaScript. Наш код – только внутри исполнителя.
        
        Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:
        
        - `resolve(value)` — если работа завершилась успешно, с результатом `value`.
        - `reject(error)` — если произошла ошибка, `error` – объект ошибки.
        
        Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать `resolve` или `reject`.
        
        У объекта `promise`, возвращаемого конструктором `new Promise`, есть внутренние свойства:
        
        - `state` («состояние») — вначале `"pending"` («ожидание»), потом меняется на `"fulfilled"` («выполнено успешно») при вызове `resolve` или на `"rejected"` («выполнено с ошибкой») при вызове `reject`.
        - `result` («результат») — вначале `undefined`, далее изменяется на `value` при вызове `resolve(value)` или на `error` при вызове `reject(error)`.
        
        ### [Потребители: then, catch](https://learn.javascript.ru/promise-basics#potrebiteli-then-catch)
        
        Объект `Promise` служит связующим звеном между исполнителем («создающим» кодом или «певцом») и функциями-потребителями («фанатами»), которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов `.then` и `.catch`.
        
        ### [then](https://learn.javascript.ru/promise-basics#then)
        
        Наиболее важный и фундаментальный метод – `.then`.
        
        Первый аргумент метода `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.
        
        Второй аргумент `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.
        
        ### [catch](https://learn.javascript.ru/promise-basics#catch)
        
        Если мы хотели бы только обработать ошибку, то можно использовать `null` в качестве первого аргумента: `.then(null, errorHandlingFunction)`. Или можно воспользоваться методом `.catch(errorHandlingFunction)`, который сделает то же самое:
        
        [**Очистка: finally**](https://learn.javascript.ru/promise-basics#ochistka-finally)
        
        По аналогии с блоком `finally` из обычного `try {...} catch {...}`, у промисов также есть метод `finally`.
        
        Вызов `.finally(f)` похож на `.then(f, f)`, в том смысле, что `f` выполнится в любом случае, когда промис завершится: успешно или с ошибкой.
        
        Идея `finally` состоит в том, чтобы настроить обработчик для выполнения очистки/доведения после завершения предыдущих операций.
        
        Например, остановка индикаторов загрузки, закрытие больше не нужных соединений и т.д.
        
        ### **Async/await**
        
        Ключевое слово `async` перед объявлением функции:
        
        1. Обязывает её всегда возвращать промис.
        2. Позволяет использовать `await` в теле этой функции.
        
        Ключевое слово `await` перед промисом заставит JavaScript дождаться его выполнения, после чего:
        
        1. Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось `throw`.
        2. Иначе вернётся результат промиса.
        
        Вместе они предоставляют отличный каркас для написания асинхронного кода. Такой код легко и писать, и читать.
        
    - ES 6
        - **Что нового привнес в JS стандарт ES6 или ECMAScript2015?**
            - Стрелочные функции (Arrow Functions).
            - Классы (Classes).
            - Шаблонные строки (Template Strings).
            - Расширенные объектные литералы (Enhanced Object literals).
            - Деструктуризация (Object Destructuring).
            - Промисы (Promises).
            - Генераторы (Generators).
            - Модули (Modules).
            - Symbol.
            - Прокси (Proxies).
            - Множества (Sets).
            - Параметры по умолчанию.
            - Операторы rest и spread.
            - Блочная область видимости (ключевые слова «let» и «const»).
        - **Что такое стрелочные функции (Arrow Functions)?**
            
            Стрелочная функция — это относительно новый способ создания функций в JS. Стрелочные функции создаются быстрее и имеют более читаемый синтаксис, чем функциональные выражения. В стрелочных функциях опускается слово «function»:
            
            ```
            // ES5
            var getCurrentDate =function(){
            returnnew Date()
            }
            
            // ES6
            const getCurrentDate = () =>new Date()
            
            ```
            
            В функциональном выражении мы используем ключевое слово «return» для возврата значения. В стрелочной функции мы этого не делаем, поскольку стрелочные функции неявно возвращают значения при условии, что мы возвращаем одно выражение или значение:
            
            ```
            // ES5
            functiongreet(name){
            return 'Hello ' + name + '!'
            }
            
            // ES6
            const greet = (name) => `Hello ${name}`
            const greet2 = name = > `Hello ${name}`
            
            ```
            
            Мы также можем передавать параметры стрелочным функциям. Если мы передаем один параметр, его можно не оборачивать в круглые скобки:
            
            ```
            const getArgs = () => arguments
            
            const getArgs2 = (...rest) => rest
            
            ```
            
            У стрелочных функций нет доступа к объекту arguments. Поэтому вызов первой функции приведет к ошибке. Для получения параметров, переданных функции, мы можем использовать оператор rest.
            
            ```
            const data = {
                result: 0
                nums: [1,2,3,4,5]
                computeResult(){
                    // this ссылается на объект data
            const addAll = () => {
                    // стрелочные функции копируют значение this из лексического окружения
            returnthis.nums.reduce((total, cur) => total + cur, 0)
                    }
            this.result = addAll()
                }
            }
            ```
            
            - **Когда следует использовать стрелочные функции, которые появились в ES6?**
                
                Вот простые правила по использованию различных способов объявления функций, которыми я руководствуюсь, разрабатывая код для сред, поддерживающих стандарт ES6 и более новые стандарты:
                
                - Используйте ключевое слово function в глобальной области видимости и для свойств `Object.prototype`.
                - Используйте ключевое слово function для конструкторов объектов.
                - В остальных случаях используйте стрелочные функции.
                
                Как видите, стрелочные функции рекомендуется использовать практически везде. У такого положения дел есть несколько причин:
                
                - Удобная работа с контекстом. Стрелочные функции используют значение `this` окружающего контекста, не имея собственного `this`. Если такие функции применяются последовательно, без использования обычных функций в сложных конструкциях, это обеспечивает безопасную работу с контекстом.
                - Компактность. Код стрелочных функций легче вводить и легче читать. Возможно, это преимущество стрелочных функций перед обычными покажется вам спорным и зависящим от точки зрения каждого конкретного разработчика.
                - Ясность кода. Если практически весь код представлен стрелочными функциями, любая обычная функция выделяется в таком коде тем, что создаёт собственный контекст. Применяя стрелочные функции, программист создаёт более понятный код, в котором легче, чем в коде без стрелочных функций, работать с `this`.
        - **Что такое классы (Classes)?**
            
            [Класс: базовый синтаксис](https://learn.javascript.ru/class)
            
            [Наследование классов](https://learn.javascript.ru/class-inheritance)
            
            [Статические свойства и методы](https://learn.javascript.ru/static-properties-methods)
            
            [Приватные и защищённые методы и свойства](https://learn.javascript.ru/private-protected-properties-methods)
            
            [Расширение встроенных классов](https://learn.javascript.ru/extend-natives)
            
            [Проверка класса: "instanceof"](https://learn.javascript.ru/instanceof)
            
            [Примеси](https://learn.javascript.ru/mixins)
            
            Классы — это относительно новый способ написания функций-конструкторов в JS. Это синтаксический сахар для функций-конструкторов. В основе классов лежат те же прототипы и прототипное наследование:
            
            ```jsx
            // ES5
            functionPerson(firstName, lastName, age, address){
            this.firstName = firstName
            this.lastName = lastName
            this.age = age
            this.address = address
            }
            
            Person.self =function(){
            returnthis
            }
            
            Person.prototype.toString =function(){
            return '[object Person]'
            }
            
            Person.prototype.getFullName =function(){
            returnthis.firstName + ' ' +this.lastName
            }
            
            // ES6
            class Person{
            constructor(firstName, lastName, age, address){
            this.firstName = firstName
            this.lastName = lastName
            this.age = age
            this.address = address
                }
            
            static self(){
            returnthis
                }
            
                toString(){
            return '[object Person]'
                }
            
                getFullName(){
            return `${this.firstName} ${this.lastName}`
                }
            }
            
            ```
            
            Переопределение методов и наследование от другого класса:
            
            ```jsx
            // ES5
            Employee.prototype = Object.create(Person.prototype)
            
            function Employee(firstName, lastName, age, address, jobTitle, yearStarted){
                Person.call(this, firstName, lastName, age, address)
            			this.jobTitle = jobTitle
            			this.yearStarted = yearStarted
            }
            
            Employee.prototype.describe =function(){
            return `I am ${this.getFullName()} and I have a position of #{this.jobTitle} and I started at ${this.yearStarted}}`
            }
            
            Employee.prototype.toString =function(){
            return '[object Employee]'
            }
            
            // ES6
            classEmployeeextendsPerson{ // наследуемся от Person
            constructor(firstName, lastName, age, address, jobTitle, yearStarted){
            super(firstName, lastName, age, address)
            this.jobTitle = jobTitle
            this.yearStarted = yearStarted
                }
            
                describe(){
            return `I am ${this.getFullName()} and I have a position of #{this.jobTitle} and I started at ${this.yearStarted}}`
                }
            
                toString(){ // переопределяем метод toString класса Person
            return '[object Employee]'
                }
            }
            
            ```
            
            Как узнать об использовании прототипов?
            
            ```jsx
            classSomething{ }
            
            functionAnotherSomething(){ }
            
            constas =new AnotherSomething()
            const s =new Something()
            
            console.log(typeof Something) // function
            console.log(typeof AnotherSomething) // function
            console.log(as.toString()) // [object Object]
            console.log(a.toString()) // [object Object]
            console.log(as.toString === Object.prototype.toString)
            console.log(a.toString === Object.prototype.toString)
            // в обоих случаях получаем true
            // Object.prototype находится на вершине цепочки прототипов
            // Something и AnotherSomething наследуют от Object.prototype
            ```
            
            - **В чём разница между ES6-классами и конструкторами функций?**
                
                Сначала рассмотрим примеры.
                
                Функция-конструктор:
                
                ```jsx
                function Person(name) {
                  this.name = name;
                }
                ```
                
                ES6-класс:
                
                ```jsx
                class Person {
                  constructor(name) {
                    this.name = name;
                  }
                }
                ```
                
                Если речь идёт о создании простых объектов, то конструкторы и классы, используемые для этой цели, выглядят очень похоже.
                
                Основная разница между конструкторами и классами проявляется при использовании наследования. Если нам нужно создать класс Student, являющийся подклассом класса Person, и добавить к этому новому классу поле studentId, то вот как будет выглядеть код, в котором используются конструкторы, и код, в котором применяются классы.
                
                Функция-конструктор:
                
                ```jsx
                function Student(name, studentId) {
                  // Вызываем конструктор суперкласса для инициализации полей, унаследованных от него.
                  Person.call(this, name);
                
                  // Инициализация собственных полей объекта.
                  this.studentId = studentId;
                }
                
                Student.prototype = Object.create(Person.prototype);
                Student.prototype.constructor = Student;
                ```
                
                ES6-класс:
                
                ```jsx
                class Student extends Person {
                  constructor(name, studentId) {
                    super(name);
                    this.studentId = studentId;
                  }
                }
                ```
                
        - **Что такое конструктор класса?**
        - **Что такое деструктуризация объекта (Object Destructuring)?**
            
            Деструктуризация — относительно новый способ получения (извлечения) значений объекта или массива.
            
            Допустим, у нас есть такой объект:
            
            ```
            const employee = {
                firstName: 'Marko',
                lastName: 'Polo',
                position: 'Software Developer',
                yearHired: 2017
            }
            
            ```
            
            Раньше для получения свойств объекта мы создавали переменные для каждого свойства. Это было очень скучно и сильно раздражало:
            
            ```
            var firstName = employee.firstName
            var lastName = employee.lastName
            var position = employee.position
            var yearHired = employee.yearHired
            
            ```
            
            Использование деструктуризации позволяет сделать код чище и отнимает меньше времени. Синтаксис деструктуризации следующий: заключаем свойства объекта, которые хотим получить, в фигурные скобки ({ }), а если речь идет о массиве — в квадратные скобки ([ ]):
            
            ```
            let { firstName, lastName, position, yearHired } = employee
            
            ```
            
            Для изменения имени переменной следует использовать «propertyName: newName»:
            
            ```
            let { firstName: fName, lastName: lName, position, yearHired } = employee
            
            ```
            
            Для присвоения переменным значения по умолчанию следует использовать «propertyName = 'defaultValue'»:
            
            ```
            let { firstName = 'Mark', lastName: lName, position, yearHired } = employee
            ```
            
        - **Что такое модули (Modules)?**
            
            Модули позволяют объединять (использовать) код из разных файлов и избавляют нас от необходимости держать весь код в одном большом файле. До появления модулей в JS существовало две популярные системы модулей для поддержки кода:
            
            - CommonJS — Nodejs
            - AMD (AsyncronousModuleDefinition) — Browsers
            
            Синтаксис модулей очень простой: мы используем import для импорта функциональности или значений из другого файла или файлов и export для экспорта.
            
            Экспорт функциональности в другой файл (именной экспорт):
            
            ```
            // ES5 CommonJS - helpers.js
            exports.isNull =function(val){
            return val === null
            }
            
            exports.isUndefined =function(val){
            return val === undefined
            }
            
            exports.isNullOrUndefined =function(val){
            return exports.isNull(val) || exports.isUndefined(val)
            }
            
            // ES6 модули
            exportfunctionisNull(val){
            return val === null;
            }
            
            exportfunctionisUndefined(val) {
            return val === undefined;
            }
            
            exportfunctionisNullOrUndefined(val) {
            return isNull(val) || isUndefined(val);
            }
            
            ```
            
            Импорт функциональности в другой файл:
            
            ```
            // ES5 CommonJS - index.js
            const helpers = require('./helpers.js')
            const isNull = helpers.isNull
            const isUndefined = helpers.isUndefined
            const isNullOrUndefined = helpers.isNullOrUndefined
            
            // либо с помощью деструктуризации
            const { isNull, isUndefined, isNullOrUndefined } = require('./helpers.js')
            
            // ES6 модули
            import *as helpersfrom './helpers.js' // helpers - это объект
            
            // либо
            import { isNull, isUndefined, isNullOrUndefinedas isValid}from './helpers.js' // используем "as" для переименовывания
            
            ```
            
            Экспорт по умолчанию:
            
            ```
            // ES5 CommonJS - index.js
            class Helpers {
            static isNull(val){
            return val === null
                }
            
            static isUndefined(val){
            return val === undefined
                }
            
            static isNullOrUndefined(val){
            returnthis.isNull(val) ||this.isUndefined(val)
                }
            }
            
            module.exports = Helpers
            
            // ES6 модули
            classHelpers {
            static isNull(val){
            return val === null
                }
            
            static isUndefined(val){
            return val === undefined
                }
            
            static isNullOrUndefined(val){
            returnthis.isNull(val) ||this.isUndefined(val)
                }
            }
            
            export default Helpers
            
            ```
            
            Импорт:
            
            ```
            // ES5 CommonJS - index.js
            const Helpers = require('./helpers.js')
            console.log(Helpers.isNull(null))
            
            // ES6 модули
            import Helpers from './helpers.js'
            console.log(Helpers.isNull(null))
            
            ```
            
            Это базовое использование модулей. Я не стал вдаваться в подробности, поскольку мой пост и без того получается слишком большим.
            
    - Function
        - **Функция-конструктор**
            
            Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:
            
            1. Имя функции-конструктора должно начинаться с большой буквы.
            2. Функция-конструктор должна выполняться только с помощью оператора `"new"`.
            
            ---
            
            Когда функция вызывается как `new User(...)`, происходит следующее:
            
            1. Создаётся новый пустой объект, и он присваивается `this`.
            2. Выполняется тело функции. Обычно оно модифицирует `this`, добавляя туда новые свойства.
            3. Возвращается значение `this`.
            
            ```jsx
            function User(name) {
              if (!new.target) { // в случае, если вы вызвали меня без оператора new
                return new User(name); // ...я добавлю new за вас
              }
            
              this.name = name;
            }
            
            let john = User("John"); // переадресовывает вызов на new User
            alert(john.name); // John
            ```
            
        - **Что такое поднятие (Hoisting)?**
            
            [Поднятие - Глоссарий | MDN](https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%9F%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5)
            
            Поднятие — это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости.
            
            Для того, чтобы понять, что такое Hoisting, необходимо разобраться с тем, что представляет собой контекст выполнения.
            
            Контекст выполнения — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение.
            
            Компиляция. В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления — прим. пер.).
            
            Выполнение. В этой фазе переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются.
            
            Запомните: поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются.
            
            Предположим, что у нас есть такой код:
            
            ```
            console.log(y)
            y = 1
            console.log(y)
            console.log(greet('Mark'))
            
            functiongreet(name) {
            return 'Hello ' + name + '!'
            }
            
            var y
            
            ```
            
            Получаем undefined, 1 и 'Hello Mark!'.
            
            Вот как выглядит фаза компиляции:
            
            ```
            functiongreet(name) {
            return 'Hello ' + name + '!'
            }
            
            var y // присваивается undefined
            
            // ожидается завершение фазы компиляции
            
            // затем начинается фаза выполнения
            /*
            console.log(y)
            y = 1
            console.log(y)
            console.log(greet('Mark'))
            */
            
            ```
            
            После завершения фазы компиляции начинается фаза выполнения, когда переменным присваиваются значения и вызываются функции.
            
            Дополнительно о Hoisting можно почитать [здесь](https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%9F%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5).
            
        - **Контекст выполнения, стек**
            
            Информация о процессе выполнения запущенной функции хранится в её *контексте выполнения* (execution context).
            
            [Контекст выполнения](https://tc39.github.io/ecma262/#sec-execution-contexts) – специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение `this` (мы не используем его в данном примере) и прочую служебную информацию.
            
            Один вызов функции имеет ровно один контекст выполнения, связанный с ним.
            
            Когда функция производит вложенный вызов, происходит следующее:
            
            - Выполнение текущей функции приостанавливается.
            - Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – *стеке контекстов выполнения*.
            - Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
            - После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.
        - **Параллельная модель и цикл событий.**
            
            Параллелизм/Многопоточность в JavaScript работает за счёт цикла событий (**event loop**), который отвечает за выполнение кода, сбора и обработки событий и выполнения под-задач из очереди (**queued sub-tasks**). Эта модель весьма отличается от других языков программирования, таких как C и Java.
            
            ## [Концепция жизненного цикла](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop#%D0%BA%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%86%D0%B8%D1%8F_%D0%B6%D0%B8%D0%B7%D0%BD%D0%B5%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE_%D1%86%D0%B8%D0%BA%D0%BB%D0%B0)
            
            В следующей секции объясняется теоретическая модель. Современные JavaScript движки внедряют/имплементируют и существенно оптимизируют этот процесс.
            
            ### [Визуальное представление](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop#%D0%B2%D0%B8%D0%B7%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5)
            
            ![https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop/the_javascript_runtime_environment_example.svg](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop/the_javascript_runtime_environment_example.svg)
            
            Для лучшего **визуального** представления работы **Event loop**, Вы можете ознакомиться с данным видео: [https://www.youtube.com/watch?v=8aGhZQkoFbQ&t=389s](https://www.youtube.com/watch?v=8aGhZQkoFbQ&t=389s)
            
            ### [Стек](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop#%D1%81%D1%82%D0%B5%D0%BA)
            
            Вызов любой функции создаёт контекст выполнения ([Execution Context (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth)). При вызове вложенной функции создаётся новый контекст, а старый сохраняется в специальной структуре данных - стеке вызовов (Call Stack).
            
            `function f(b) {
              var a = 12;
              return a + b + 35;
            }
            
            function g(x) {
              var m = 4;
              return f(m * x);
            }
            
            g(21);`
            Copy to Clipboard
            
            Когда вызывается функция `g`, создаётся первый контекст выполнения, содержащий аргументы функции `g` и локальные переменные. Когда `g` вызывает `f`, создаётся второй контекст с аргументами `f` и её локальными переменными. И этот контекст выполнения `f` помещается в стек вызовов выше первого. Когда `f` возвращает результат, верхний элемент из стека удаляется. Когда `g` возвращает результат, её контекст также удалится, и стек становится пустым.
            
            ### [Куча](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop#%D0%BA%D1%83%D1%87%D0%B0)
            
            Объекты размещаются в [куче](https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D1%87%D0%B0_(%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C)). Куча — это просто имя для обозначения большой неструктурированной области памяти.
            
            ### [Очередь](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop#%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C)
            
            Среда выполнения JavaScript содержит очередь задач. Эта очередь — список задач, подлежащих обработке. Каждая задача ассоциируется с некоторой функцией, которая будет вызвана, чтобы обработать эту задачу.
            
            Когда стек полностью освобождается, самая первая задача извлекается из очереди и обрабатывается. Обработка задачи состоит в вызове ассоциированной с ней функции с параметрами, записанными в этой задаче. Как обычно, вызов функции создаёт новый контекст выполнения и заносится в стек вызовов.
            
            Обработка задачи заканчивается, когда стек снова становится пустым. Следующая задача извлекается из очереди и начинается её обработка.
            
            ## [Цикл событий](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop#%D1%86%D0%B8%D0%BA%D0%BB_%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9)
            
            Модель событийного цикла (`event loop`) называется так потому, что отслеживает новые события в цикле:
            
            `while(queue.waitForMessage()){
              queue.processNextMessage();
            }`
            Copy to Clipboard
            
            `queue.waitForMessage` ожидает поступления задач, если очередь пуста.
            
            ### [Запуск до завершения](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop#%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA_%D0%B4%D0%BE_%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B5%D0%BD%D0%B8%D1%8F)
            
            Каждая задача выполняется полностью, прежде чем начнёт обрабатываться следующая. Благодаря этому мы точно знаем: когда выполняется текущая функция – она не может быть приостановлена и будет целиком завершена до начала выполнения другого кода (который может изменить данные, с которыми работает текущая функция). Это отличает JavaScript от такого языка программирования как C. Поскольку в С функция, запущенная в отдельном потоке, в любой момент может быть остановлена, чтобы выполнить какой-то другой код в другом потоке.
            
            У данного подхода есть и минусы. Если задача занимает слишком много времени, то веб-приложение не может обрабатывать действия пользователя в это время (например, скролл или клик). Браузер старается смягчить проблему и выводит сообщение *"скрипт выполняется слишком долго" ("a script is taking too long to run")* и предлагает остановить его. Хорошей практикой является создание задач, которые исполняются быстро, и если возможно, разбиение одной задачи на несколько мелких.
            
            ### [Добавление событий в очередь](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop#%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9_%D0%B2_%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C)
            
            В браузерах события добавляются в очередь в любое время, если событие произошло, а так же если у него есть обработчик. В случае, если обработчика нет – событие потеряно. Так, клик по элементу, имеющему обработчик события по событию `click`, добавит событие в очередь, а если обработчика нет – то и событие в очередь не попадёт.
            
            Вызов [setTimeout](https://developer.mozilla.org/ru/docs/Web/API/setTimeout) добавит событие в очередь по прошествии времени, указанного во втором аргументе вызова. Если очередь событий на тот момент будет пуста, то событие обработается сразу же, в противном случае событию функции `setTimeout` придётся ожидать завершения обработки остальных событий в очереди. Именно поэтому второй аргумент `setTimeout` корректно считать не временем, через которое выполнится функция из первого аргумента, а минимальное время, через которое она сможет выполниться.
            
            ### [Нулевые задержки](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop#%D0%BD%D1%83%D0%BB%D0%B5%D0%B2%D1%8B%D0%B5_%D0%B7%D0%B0%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B8)
            
            Нулевая задержка не даёт гарантии, что обработчик выполнится через ноль миллисекунд. Вызов [`setTimeout`](https://developer.mozilla.org/ru/docs/Web/API/setTimeout) с аргументом 0 (ноль) не завершится за указанное время. Выполнение зависит от количества ожидающих задач в очереди. Например, сообщение ''this is just a message'' из примера ниже будет выведено на консоль раньше, чем произойдёт выполнение обработчика *cb1*. Это произойдёт, потому что задержка – это минимальное время, которое требуется среде выполнения на обработку запроса.
            
            `(function () {
            
              console.log('this is the start');
            
              setTimeout(function cb() {
                console.log('this is a msg from call back');
              });
            
              console.log('this is just a message');
            
              setTimeout(function cb1() {
                console.log('this is a msg from call back1');
              }, 0);
            
              console.log('this is the end');
            
            })();
            
            // "this is the start"
            // "this is just a message"
            // "this is the end"
            // "this is a msg from call back"
            // "this is a msg from call back1"`
            Copy to Clipboard
            
            ### [Связь нескольких потоков между собой](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop#%D1%81%D0%B2%D1%8F%D0%B7%D1%8C_%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%B8%D1%85_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2_%D0%BC%D0%B5%D0%B6%D0%B4%D1%83_%D1%81%D0%BE%D0%B1%D0%BE%D0%B9)
            
            Web Worker или кросс-доменный фрейм имеют свой собственный стек, кучу и очередь событий. Два отдельных событийных потока могут связываться друг с другом, только через отправку сообщений с помощью метода `postMessage`. Этот метод добавляет сообщение в очередь другого, если он конечно принимает их.
            
            ## [Никогда не блокируется](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop#%D0%BD%D0%B8%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0_%D0%BD%D0%B5_%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D1%83%D0%B5%D1%82%D1%81%D1%8F)
            
            Очень интересное свойство цикла событий в JavaScript, что в отличие от множества других языков, поток выполнения никогда не блокируется. Обработка I/O обычно осуществляется с помощью событий и колбэк-функций, поэтому даже когда приложение ожидает запрос от [IndexedDB](https://developer.mozilla.org/ru/docs/Web/API/IndexedDB_API) или ответ от [XHR](https://developer.mozilla.org/ru/docs/Web/API/XMLHttpRequest), оно может обрабатывать другие процессы, например пользовательский ввод.
            
            Существуют хорошо известные исключения как `alert` или синхронный XHR, но считается хорошей практикой избегать их использования.
            
        - **Что такое область видимости (Scope)?**
            
            Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).
            
            Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде.
            
            ```
            // глобальное пространство имен
            var g = 'global'
            
            functionglobalFunc() {
            functioninnerFunc() {
                    console.log(g) // имеет доступ к переменной g, поскольку она является глобальной
                }
                innerFunc()
            }
            
            ```
            
            Функциональная область видимости (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции.
            
            ```
            functionmyFavouriteFunc(a) {
            if (true) {
            var b = 'Hello ' + a
                }
            return b
            }
            myFavouriteFunc('World')
            
            console.log(a) // Uncaught ReferenceError: a is not defined
            console.log(b) // не выполнится
            
            ```
            
            Блочная область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него.
            
            ```
            functiontestBlock() {
            if (true) {
            let z = 5
                }
            return z
            }
            
            testBlock() // Uncaught ReferenceError: z is not defined
            
            ```
            
            Область видимости — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется цепочкой областей видимости (Scope Chain).
            
            ```
            // цепочка областей видимости
            // внутренняя область видимости -> внешняя область видимости -> глобальная область видимости
            
            // глобальная область видимости
            var variable1 = 'Comrades'
            var variable2 = 'Sayonara'
            
            functionouter() {
                // внешняя область видимости
            var variable1 = 'World'
            
            functioninner() {
                    // внутренняя область видимости
            var variable2 = 'Hello'
                    console.log(variable2 + ' ' + variable1)
                }
                inner()
            }
            outer()
            // в консоль выводится 'Hello World',
            // потому что variable2 = 'Hello' и variable1 = 'World' являются ближайшими
            // к внутренней области видимости переменными
            
            ```
            
            ![https://habrastorage.org/r/w1560/webt/r6/07/q7/r607q7hehfjmuicf0_icntddk2s.png](https://habrastorage.org/r/w1560/webt/r6/07/q7/r607q7hehfjmuicf0_icntddk2s.png)
            
        - **Что такое замыкание (Closures)?**
            - MDN
                
                Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ к [Scope](%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B%20%D0%BA%20%D1%81%D0%BE%D0%B1%D0%B5%D1%81%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E%208ede8bfc1bda4fe3892de94493e99044.md)
                внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.
                
                ## Замыкания на практике
                
                Замыкания полезны тем, что позволяют связать данные (лексическое окружение) с функцией, которая работает с этими данными. Очевидна параллель с объектно-ориентированным программированием, где объекты позволяют нам связать некоторые данные (свойства объекта) с одним или несколькими методами.
                
                Следовательно, замыкания можно использовать везде, где вы обычно использовали объект с одним единственным методом.
                
                Такие ситуации повсеместно встречаются в web-разработке. Большое количество front-end кода, который мы пишем на JavaScript, основано на обработке событий. Мы описываем какое-то поведение, а потом связываем его с событием, которое создаётся пользователем (например, клик мышкой или нажатие клавиши). При этом наш код обычно привязывается к событию в виде обратного/ответного вызова (callback): *callback функция - функция выполняемая в ответ на возникновение события*.
                
                Давайте рассмотрим практический пример: допустим, мы хотим добавить на страницу несколько кнопок, которые будут менять размер текста. Как вариант, мы можем указать свойство font-size на элементе body в пикселах, а затем устанавливать размер прочих элементов страницы (таких, как заголовки) с использованием относительных единиц em:
                
                ```html
                body {
                  font-family: Helvetica, Arial, sans-serif;
                  font-size: 12px;
                }
                
                h1 {
                  font-size: 1.5em;
                }
                
                h2 {
                  font-size: 1.2em;
                }
                ```
                
                Тогда наши кнопки будут менять свойство font-size элемента body, а остальные элементы страницы просто получат это новое значение и отмасштабируют размер текста благодаря использованию относительных единиц.
                
                Используем следующий JavaScript:
                
                ```jsx
                function makeSizer(size) {
                  return function() {
                    document.body.style.fontSize = size + 'px';
                  };
                };
                
                var size12 = makeSizer(12);
                var size14 = makeSizer(14);
                var size16 = makeSizer(16);
                ```
                
                Теперь `size12`, `size14`, и `size16`- это функции, которые меняют размер текста в элементе body на значения 12, 14, и 16 пикселов, соответственно. После чего мы цепляем эти функции на кнопки примерно так:
                
                ```jsx
                document.getElementById('size-12').onclick = size12;
                document.getElementById('size-14').onclick = size14;
                document.getElementById('size-16').onclick = size16;
                
                <a href="#" id="size-12">12</a>
                <a href="#" id="size-14">14</a>
                <a href="#" id="size-16">16</a>
                ```
                
                [Замыкание](https://learn.javascript.ru/closure)
                
                [Области видимости - JavaScript - Дока](https://doka.guide/js/closures/)
                
                ---
                
                Наверное, это самый сложный вопрос из списка. Я постараюсь объяснить, как я понимаю замыкание.
                
            
            [Замыкания - JavaScript | MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures)
            
            По сути, замыкание — это способность функции во время создания запоминать ссылки на переменные и параметры, находящиеся в текущей области видимости, в области видимости родительской функции, в области видимости родителя родительской функции и так до глобальной области видимости с помощью цепочки областей видимости. Обычно область видимости определяется при создании функции.
            
            Примеры — отличный способ объяснить замыкание:
            
            ```jsx
            // глобальная область видимости
            var globalVar = 'abc'
            
            function a() {
                **// область видимости функции
                console.log(globalVar)
            }**
            
            a() // 'abc'
            // цепочка областей видимости
            // область видимости функции a -> глобальная область видимости
            
            ```
            
            В данном примере, когда мы объявляем функцию, глобальная область видимости является частью замыкания.
            
            ![https://habrastorage.org/r/w1560/webt/10/ke/qa/10keqaosrww0rntbyei1gx9f_k0.png](https://habrastorage.org/r/w1560/webt/10/ke/qa/10keqaosrww0rntbyei1gx9f_k0.png)
            
            Переменная «globalVar» не имеет значения на картинке, потому что ее значение может меняться в зависимости от того, где и когда будет вызвана функция. Но в примере выше globalVar будет иметь значение «abc».
            
            Теперь пример посложнее:
            
            ```jsx
            var globalVar = 'global'
            var outerVar = 'outer'
            
            function outerFunc(outerParam) {
            	function innerFunc(innerParam) {
                    console.log(globalVar, outerParam, innerParam)
                }
            	return innerFunc
            }
            
            const x = outerFunc(outerVar)
            outerVar = 'outer-2'
            globalVar = 'guess'
            x('inner')
            
            ```
            
            ![https://habrastorage.org/r/w1560/webt/ms/dv/wx/msdvwxdxp5s3l4cquxnqgkdtyr0.png](https://habrastorage.org/r/w1560/webt/ms/dv/wx/msdvwxdxp5s3l4cquxnqgkdtyr0.png)
            
            В результате получаем «guess outer inner». Объяснение следующее: когда мы вызываем функцию outerFunc и присваиваем переменной «x» значение, возвращаемое функцией innerFunc, параметр «outerParam» равняется «outer». Несмотря на то, что мы присвоили переменной «outerVar» значение «outer-2», это произошло после вызова функции outerFunc, которая «успела» найти значение переменной «outerVar» в цепочке областей видимости, этим значением было «outer». Когда мы вызываем «x», которая ссылается на innerFunc, значением «innerParam» является «inner», потому что мы передаем это значение в качестве параметра при вызове «x». globalVar имеет значение «guess», потому что мы присвоили ей это значение перед вызовом «x».
            
            Пример неправильного понимания замыкания.
            
            ```jsx
            const arrFunc = []
            for (var i = 0; i < 5; i++) {
                arrFunc.push(function() {
            return i
                })
            }
            console.log(i) // 5
            
            for (let i = 0; i < arrFunc.length; i++) {
                console.log(arrFunc[i]()) // все 5
            }
            
            ```
            
            Данный код работает не так, как ожидается. Объявление переменной с помощью ключевого слова «var» делает эту переменную глобальной. После добавления функций в массив «arrFunc» значением глобальной переменной «i» становится «5». Поэтому когда мы вызываем функцию, она возвращает значение глобальной переменной «i». Замыкание хранит ссылку на переменную, а не на ее значение во время создания. Эту проблему можно решить, используя IIFE или объявив переменную с помощью ключевого слова «let».
            
            Подробнее о замыкании можно почитать [здесь](https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures) и [здесь](https://learn.javascript.ru/closure).
            
        - **Рекурсия**
            
            [Рекурсия - JavaScript - Дока](https://doka.guide/js/recursion/)
            
        - **this**
            
            [Методы объекта, "this"](https://learn.javascript.ru/object-methods#klyuchevoe-slovo-this-v-metodah)
            
            [this: контекст выполнения функций - JavaScript - Дока](https://doka.guide/js/function-context/)
            
            Обычно this ссылается на значение объекта, который в данный момент выполняет или вызывает функцию. «В данный момент» означает, что значение this меняется в зависимости от контекста выполнения, от того места, где мы используем this.
            
            ```jsx
            const carDetails = {
                name: 'Ford Mustang',
                yearBought: 2005,
                getName() {
            return this.name
                }
                isRegistered: true
            }
            
            console.log(carDetails.getName()) // Ford Mustang
            
            ```
            
            В данном случае метод getName возвращает this.name, а this ссылается на carDetails, объект, в котором выполняется getName, который является ее «владельцем».
            
            Добавим после console.log три строчки:
            
            ```jsx
            var name = 'Ford Ranger'
            var getCarName = carDetails.getName
            
            console.log(getCarName()) // Ford Ranger
            
            ```
            
            Второй console.log выдает Ford Ranger, и это странно. Причина такого поведения заключается в том, что «владельцем» getCarName является объект window. Переменные, объявленные с помощью ключевого слова «var» в глобальной области видимости, записываются в свойства объекта window. this в глобальной области видимости ссылается на объект window (если речь не идет о строгом режиме).
            
            ```jsx
            console.log(getCarName === window.getCarName) // true
            console.log(getCarName ===this.getCarName) // true
            
            ```
            
            В этом примере this и window ссылаются на один объект.
            
            Одним из способов решения данной проблемы является использование методов call или apply:
            
            ```jsx
            console.log(getCarName.apply(carDetails)) // Ford Mustang
            console.log(getCarName.call(carDetails)) // Ford Mustang
            
            ```
            
            Call и apply принимают в качестве первого аргумента объект, который будет являться значением this внутри функции.
            
            В IIFE, функциях, которые создаются в глобальном области видимости, анонимных функциях и внутренних функциях методов объекта значением this по умолчанию является объект window.
            
            ```jsx
            (function() {
                console.log(this)
            })() // window
            
            functioniHateThis() {
                console.log(this)
            }
            iHateThis() // window
            
            const myFavouriteObj = {
                guessThis() {
            functiongetName() {
                        console.log(this.name)
                    }
                    getName()
                },
                name: 'Marko Polo',
                thisIsAnnoying(callback) {
                    callback()
                }
            }
            
            myFavouriteObj.guessThis() // window
            myFavouriteObj.thisIsAnnoying(function() {
                console.log(this) // window
            })
            
            ```
            
            Существует два способа получить «Marko Polo».
            
            Во-первых, мы можем сохранить значение this в переменной:
            
            ```jsx
            const myFavoriteObj = {
                guessThis() {
            const self =this // сохраняем значение this в переменной self
            functiongetName() {
                        console.log(self.name)
                    }
                    getName()
                },
                name: 'Marko Polo',
                thisIsAnnoying(callback) {
                    callback()
                }
            }
            
            ```
            
            Во-вторых, мы можем использовать стрелочную функцию:
            
            ```
            const myFavoriteObj = {
                guessThis() {
            const getName = () => {
                        // копируем значение this из внешнего окружения
                        console.log(this.name)
                    }
                    getName()
                },
                name: 'Marko Polo',
                thisIsAnnoying(callback) {
                    callback()
                }
            }
            
            ```
            
            Стрелочные функции не имеют собственного значения this. Они копируют значение this из внешнего лексического окружения.
            
        - **Что такое IIFE**
            
            IIFE или Immediately Invoked Function Expression — это функция, которая вызывается или выполняется сразу же после создания или объявления. Для создания IIFE необходимо обернуть функцию в круглые скобки (оператор группировки), превратив ее в выражение, и затем вызвать ее с помощью еще одних круглых скобок. Это выглядит так: (function(){})().
            
            ```
            (function( ) { }( ))
            
            (function( ) { })( )
            
            (functionnamed(params) { })( )
            
            (( ) => { })
            
            (function(global) { })(window)
            
            const utility = (function( ) {
            return {
                    // утилиты
                }
            })
            
            ```
            
            Все эти примеры являются валидными. Предпоследний пример показывает, что мы можем передавать параметры в IIFE. Последний пример показывает, что мы можем сохранить результат IIFE в переменной.
            
            Лучшее использование IIFE — это выполнение функций настройки инициализации и предотвращение конфликтов имен с другими переменными в глобальной области видимости (загрязнение глобального пространства имен). Приведем пример.
            
            ```
            <script src="https://cdnurl.com/somelibrary.js"></script>
            
            ```
            
            У нас есть ссылка на библиотеку somelibrary.js, которая предоставляет некоторые глобальные функции, которые мы можем использовать в нашем коде, но в этой библиотеке есть два метода, createGraph и drawGraph, которые мы не используем, потому что они содержат ошибки. И мы хотим реализовать эти функции самостоятельно.
            
            Одним из способов решить данную проблему является изменение структуры наших скриптов:
            
            ```
            <script src="https://cdnurl.com/somelibrary.js"></script>
            <script>
                function createGraph() {
                    // код
                }
            
                function drawGraph() {
                    // код
                }
            </script>
            
            ```
            
            Таким образом, мы переопределяем методы, предоставляемые библиотекой.
            
            Вторым способом является изменение имен наших функций:
            
            ```
            <script src="https://cdnurl.com/somelibrary.js"></script>
            <script>
                function myCreateGraph() {
                    // код
                }
            
                function myDrawGraph() {
                    // код
                }
            </script>
            
            ```
            
            Третий способ — использование IIFE:
            
            ```
            <script>
            const graphUtility = (function() {
            functioncreateGraph() {
                        // код
                    }
            
            functiondrawGraph() {
                        // код
                    }
            return {
                        createGraph,
                        drawGraph
                    }
                })
            </script>
            
            ```
            
            В этом примере мы создаем служебную переменную, которая содержит результат IIFE, возвращающий объект, содержащий методы createGraph и drawGraph.
            
            Вот еще одна проблема, которую можно решить с помощью IIFE:
            
            ```
            val li = document.querySelectorAll('.list-group > li')
            for (var i - 0, len = li.length; i < len; i++) {
                li[i].addEventListener('click',function(e) {
                    console.log(i)
                })
            }
            
            ```
            
            Допустим, у нас есть элемент «ul» с классом «list-group», содержащий 5 дочерних элементов «li». И мы хотим выводить в консоль значение «i» при клике по отдельному «li». Однако вместо этого в консоль всегда выводится 5. Виной всему замыкание.
            
            Одним из решений является IIFE:
            
            ```
            var li = document.querySelectorAll('.list-group > li')
            for (var i = 0, len = li.length; i < len; i++) {
                (function(currentIndex) {
                    li[currentIndex].addEventListener('click',function(e) {
                        console.log(currentIndex)
                    })
                })(i)
            }
            
            ```
            
            Причина, по которой этот код работает, как задумано, состоит в том, что IIFE создает новую область видимости на каждой итерации, и мы записываем значение «i» в currentIndex.
            
        - **Что такое генераторы?**
            
            **Генераторы** — это функции, из которых можно «выходить», и в которые можно «входить» по мере необходимости. Их контекст (привязки переменных) сохраняется между сеансами "входа" в них. Генераторы объявляют с использованием ключевого слова `function*`. Такая функция, при её первом вызове, не выполняет код, возвращая особый объект, генератор, который позволяет управлять её выполнением. Для получения очередного значения, выдаваемого генератором, нужно вызвать его метод `next()`. Благодаря этому выполняется код функции до тех пор, пока в нём не встретится ключевое слово `yield`, возвращающее значение.
            
            Функцию-генератор можно вызывать сколько угодно раз. Каждый раз будет возвращаться новый генератор. Но каждый генератор можно обойти лишь один раз.
            
- **TypeScript**
    - **What is TypeScript?**
        
        TypeScript is a strongly typed superset of JavaScript created by Microsoft that adds optional types, classes, async/await and many other features, and compiles to plain JavaScript. Angular is written entirely in TypeScript as a primary language.
        
    - **Зачем нам нужны определения типов, где есть JavaScript c динамической типизацией?**
    - **Что такое Union Type (тип объединения) и для чего используется?**
    - **Что такое пользовательский тип данных?**
    - **Поддерживает ли TypeScript перегрузку методов?**
    - **Возможна ли перегрузка конструктора в TypeScript?**
    - **Что такое декоратор и какие виды декораторов вы знаете?**
        
        Декоратор — способ добавления метаданных к объявлению класса. Это специальный вид объявления, который может быть присоединен к объявлению класса, методу, методу доступа, свойству или параметру. Декораторы используют форму @expression, где expression - функция, которая будет вызываться во время выполнения с информацией о декорированном объявлении. И, чтобы написать собственный декоратор, нам нужно сделать его factory и определить тип:
        
        - ClassDecorator
        - PropertyDecorator
        - MethodDecorator
        - ParameterDecorator
        
        **Декоратор класса**
        
        Вызывается перед объявлением класса, применяется к конструктору класса и может использоваться для наблюдения, изменения или замены определения класса. Expression декоратора класса будет вызываться как функция во время выполнения, при этом конструктор декорированного класса является единственным аргументом. Если класс декоратора возвращает значение, он заменит объявление класса вернувшимся значением.
        
        ```jsx
        export function logClass(target: Function) {
          // Сохранение ссылки на оригинальный конструктор
          const original = target;
        
          // Функция генерирует экземпляры класса
          function construct(constructor, args) {
            const c: any = function () {
              return constructor.apply(this, args);
            };
            c.prototype = constructor.prototype;
            return new c();
          }
        
          // Определение поведения нового конструктора
          const f: any = function (...args) {
            console.log(`New: ${original["name"]} is created`);
            //New: Employee создан
            return construct(original, args);
          };
        
          // Копирование прототипа, чтобы оператор intanceof работал
          f.prototype = original.prototype;
        
          // Возвращает новый конструктор, переписывающий оригинальный
          return f;
        }
        
        @logClass
        class Employee {}
        
        let emp = new Employee();
        console.log("emp instanceof Employee");
        //emp instanceof Employee
        console.log(emp instanceof Employee);
        //true
        ```
        
        **Декоратор свойства**
        
        Объявляется непосредственно перед объявлением метода. Будет вызываться как функция во время выполнения со следующими двумя аргументами:
        
        - target - прототип текущего объекта, т.е. если Employee является объектом, Employee.prototype
        - propertyKey - название свойства
        
        ```jsx
        function logParameter(target: Object, propertyName: string) {
          // Значение свойства
          let _val = this[propertyName];
        
          // Геттер свойства
          const getter = () => {
            console.log(`Get: ${propertyName} => ${_val}`);
            return _val;
          };
        
          // Сеттер свойства
          const setter = (newVal) => {
            console.log(`Set: ${propertyName} => ${newVal}`);
            _val = newVal;
          };
        
          // Удаление свойства
          if (delete this[propertyName]) {
            // Создает новое свойство с геттером и сеттером
            Object.defineProperty(target, propertyName, {
              get: getter,
              set: setter,
              enumerable: true,
              configurable: true,
            });
          }
        }
        
        class Employee {
          @logParameter
          name: string;
        }
        
        const emp = new Employee();
        emp.name = "Mohan Ram";
        console.log(emp.name);
        
        // Set: name => Mohan Ram
        // Get: name => Mohan Ram
        // Mohan Ram
        ```
        
        **Декоратор метода**
        
        Объявляется непосредственно перед объявлением метода. Будет вызываться как функция во время выполнения со следующими двумя аргументами:
        
        - target - прототип текущего объекта, т.е. если Employee является объектом, Employee.prototype
        - propertyName - название свойства
        - descriptor - дескриптор свойства метода т.е. - Object.getOwnPropertyDescriptor (Employee.prototype, propertyName)
        
        ```jsx
         export function logMethod(
             target: Object,
             propertyName: string,
             propertyDescriptor: PropertyDescriptor): PropertyDescriptor {
             const method = propertyDescriptor.value;
         
             propertyDescriptor.value = function (...args: any[]) {
         
                 // Конвертация списка аргументов greet в строку
                 const params = args.map(a => JSON.stringify(a)).join();
         
                 // Вызов greet() и получение вернувшегося значения
                 const result = method.apply(this, args);
         
                 // Конвертация результата в строку
                 const r = JSON.stringify(result);
         
                 // Отображение в консоли деталей вызова
                 console.log(`Call: ${propertyName}(${params}) => ${r}`);
         
                 // Возвращение результата вызова
                 return result;
             }
             return propertyDescriptor;
         }
         
         class Employee {
         
             constructor(
                 private firstName: string,
                 private lastName: string
             ) {
             }
         
             @logMethod
             greet(message: string): string {
                 return `${this.firstName} ${this.lastName} says: ${message}`;
             }
         
         }
         
         const emp = new Employee('Mohan Ram', 'Ratnakumar');
         emp.greet('hello');
         //Call: greet("hello") => "Mohan Ram Ratnakumar says: hello"
        ```
        
        **Декоратор параметра**
        
        Объявляется непосредственно перед объявлением метода. Будет вызываться как функция во время выполнения со следующими двумя аргументами:
        
        - target - прототип текущего объекта, т.е. если Employee является объектом, Employee.prototype
        - propertyKey - название свойства
        - index - индекс параметра в массиве аргументов
        
        `function logParameter(target: Object, propertyName: string, index: number) {
          // Генерация метаданных для соответствующего метода
          // для сохранения позиции декорированных параметров
          const metadataKey = `log_${propertyName}_parameters`;
        
          if (Array.isArray(target[metadataKey])) {
            target[metadataKey].push(index);
          } else {
            target[metadataKey] = [index];
          }
        }
        
        class Employee {
          greet(@logParameter message: string): void {
            console.log(`hello ${message}`);
          }
        }
        const emp = new Employee();
        emp.greet("world");`
        

[Angular](%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B%20%D0%BA%20%D1%81%D0%BE%D0%B1%D0%B5%D1%81%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E%208ede8bfc1bda4fe3892de94493e99044/Angular%20a6c40ddcb5f4467482b44ea8b079dc03.md)

- **Общие вопросы**
    - **Назовите основные принципы ООП?**
    - **В чем отличие фреймворка от библиотеки (приведите примеры и отличия)?**
    - **Знаете ли вы как браузер обрабатывает index.html (расскажите про Critical Rendering Path)?**
- Основы сетей
    - **Расскажите про стек TCP/IP, а также более подробно про, что такое HTTP и какую роль он играет при разработке приложений?**
    - **Что такое REST API, как происходит взаимодействие (расскажите про основные коды ошибок, заголовки пакетов и способы их отправки)?**